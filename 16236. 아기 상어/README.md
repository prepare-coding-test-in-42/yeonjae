# 문제 흐름 분석

## 1. 입력 정보
- 어떤 값들이 주어지는가?
  - 첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)
  - 둘째 줄부터 N개의 줄에 공간의 상태
    - 0: 빈 칸
    - 1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기
    - 9: 아기 상어의 위치

## 2. 출력 정보
- 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력

## 3. 핵심 조건 및 규칙
- 처음에 아기 상어의 크기는 2
- 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동
- 자신의 크기보다 큰 물고기가 있는 칸은 지날 수 없음
- 자신의 크기보다 작은 물고기만 먹을 수 있음
- 자신과 크기가 같은 물고기는 먹을 수 없지만 지나갈 수 있음
- 아기 상어의 이동
  - 더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청
  - 먹을 수 있는 물고기가 한 마리라면, 그 물고기를 먹음
  - 먹을 수 있는 물고기가 한 마리보다 많은 경우 거리가 가장 가까운 물고기를 먹으러 감
    - 거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때 지나야하는 칸의 갯수의 최솟값
    - 거리가 가까운 물고기가 많다면, 좌 상단부터 우 하단까지가 먹음
  - 이동은 1초 걸리고 물고기를 먹는데 걸리는 시간은 없음
  - 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가

## 4. 문제를 상태로 표현하기
- 상어의 상태
  - 위치 = `(x, y)`
  - 크기 = `size`
  - 먹은 물고기의 수 = `cnt`
- 물고기의 상태
  - 위치 = `(x, y)`
  - 크기 = `board[x][y]`
- 공간의 상태
  - 비어있는 경우 `board[x][y] = 0`

## 5. 목표 조건
- 언제 종료되는가? 어떤 값이 최적해인가?
  - 더 이상 먹을 수 있는 물고기가 없을 때

## 6. 풀이 방법
- 어떤 알고리즘/기법을 사용할 수 있을까?
  - 우선 순위 조건이 붙은 BFS 탐색 문제

## 7. 로직 흐름 요약
1. 입력을 받아 `board` 상태와 아기 상어의 시작 위치 파악
2. 상어 크기 2, 먹은 물고기 수와 총 시간을 0으로 초기화
3. `while` 루프를 통해 아래 과정을 반복:
  a. BFS를 수행하여 먹을 수 있는 물고기들 중 가장 가까운 물고기 탐색
    - 거리가 가장 짧은 물고기
    - 같은 거리인 경우 좌상단에 위치한 물고기 우선
    - BFS가 `None`을 반환하면 먹을 수 있는 물고기가 없으므로 종료
  b. 먹을 물고기를 선택하고, 상어 위치를 이동시키며 시간에 거리만큼 더함
  c. 먹은 물고기의 수를 1 증가
    - `cnt == size`가 되면 상어의 크기 1 증가, `cnt`는 0으로 초기화
  d. 더 이상 먹을 수 있는 물고기를 반환하지 않으면 루프를 종료하고 현재까지의 시간을 출력