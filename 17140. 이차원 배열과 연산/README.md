# 🧠 문제 분석 템플릿


## 1. 📥 입력 정보

- 어떤 값이 입력으로 주어지는가?
  - 첫째 줄에 r, c, k (1 ≤ r, c, k ≤ 100)
  - 둘째 줄부터 3개의 줄에 배열 A에 들어있는 100보다 작거나 같은 자연수


## 2. 📤 출력 정보

- 출력해야 하는 최종 결과는?
  - A[r][c]에 들어있는 값이 k가 되기 위한 연산의 최소 시간을 출력
  - 100초가 지나도 A[r][c] = k가 되지 않으면 -1을 출력
- 무엇을 "최적화"하거나 "계산"하는 문제인가?


## 3. 📌 핵심 조건 요약

- 문제에서 주어진 규칙/조건은?
  - 한 행 또는 열에 있는 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지면 수가 커지는 순으로 정렬
  - 정렬 시 0 무시
  - 배열 A에 정렬된 결과를 삽입
  - 행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버림
  - 정렬된 결과를 배열에 삽입 시 수와 등장 횟수를 순서대로 삽입
- 이동/먹기/성장/중단 등 상태 변화 조건은 무엇인가?
  - R 연산: 행의 개수 ≥ 열의 개수인 경우 배열 A의 모든 행에 대해서 정렬을 수행
  - C 연산: 행의 개수 < 열의 개수인 경우 배열 A의 모든 열에 대해서 정렬을 수행


## 4. 🧾 상태(State)의 정의

- 현재 문제에서 다뤄야 할 상태는 무엇인가?
  - 각 연산 후 정렬된 배열의 상태
- 하나의 상태를 어떻게 표현할 것인가? (예: 위치, 크기, 카운터 등)
  - 배열 안의 값으로 표현


## 5. 🎯 목표 / 종료 조건

- 언제 루프/탐색을 종료해야 하는가?
  - A[r][c] == k인 순간
- 어떤 값이 답이 되는가?
  - A[r][c]에 들어있는 값이 k가 되기 위한 연산의 최소 시간


## 6. 🧠 접근 전략

- 어떤 알고리즘이 적합한가? (예: BFS, DFS, 다익스트라, 시뮬레이션, DP 등)
  - 시뮬레이션
- 이유는 무엇인가?
  - 각 연산을 문제에서 요구하는 대로 구현
- 최단 거리, 우선순위 탐색 등 특이한 요구사항은?
  - 최소 시간


## 7. 🔄 로직 흐름 요약

- 전체 흐름을 단계별로 요약
  - 매번 배열에 정렬된 결과를 다시 넣을 때 배열의 크기를 동적으로 할당하기 보다 처음부터 크기가 100인 배열을 만들고 시작하면 될 것 같음
  1. 배열 초기화
    - A = 3 x 3
  2. 매 초마다:
    - 현재 배열의 행, 열의 수 확인
    - R 또는 C 연산 선택
    - 모든 행 또는 열마다 다음 수행:
      - 0 제외한 숫자들의 등장 횟수 세기
      - (숫자, 개수) 쌍 정렬
      - [숫자, 개수, 숫자, 개수, ...]로 변환
      - 나머지는 0으로 채움
    - A[r - 1][c - 1] == k인지 확인 (r, c는 1-based index)
- 반복문, 조건문, 함수 흐름 등 포함


## 8. ⏱️ 복잡도 계산

- 시간/공간 복잡도는?
- 최악의 경우 입력 크기로부터 예상되는 수행 횟수는?


## 9. ⚠️ 예외 상황 / 테스트 케이스

- 경계 조건, 극단적인 경우는 어떻게 처리되는가?
- 예상 출력과 실제 결과가 다른 테스트 케이스는?


## 10. 🧪 디버깅 포인트 & 체크리스트

- [ ] 입력 파싱 정확히 되었는가?
- [ ] 초기 위치나 값 초기화가 누락되진 않았는가?
- [ ] 상태 변화 조건(성장, 종료 등)이 정확하게 반영되었는가?
- [ ] BFS/DFS 조건문이 올바르게 처리되었는가?
- [ ] 출력값이 문제에서 요구한 형식/조건에 맞는가?
