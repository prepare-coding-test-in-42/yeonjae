# 문제 흐름 분석

## 1. 입력 정보
- 어떤 값들이 주어지는가?
  - 네 톱니바퀴의 초기 상태 (N극: 0, S극: 1) 각 8개의 정수
  - 회전 횟수 K (1 ≤ K ≤ 100)
  - K 번 회전 방법

## 2. 출력 정보
- 최종적으로 구해야 하는 것:
  - K 번 회전시킨 후 네 톱니바퀴의 점수의 합

## 3. 핵심 조건 및 규칙
- 톱니바퀴 A를 회전할 때:
  - A와 B가 맞닿은 톱니의 극이 다르면, B는 A의 반대방향으로 회전
- K번 회전 모두 처리 후 점수 계산:
  - 1번 톱니 12시가 S극(1) → 1점
  - 2번 톱니 12시가 S극(1) → 2점
  - 3번 톱니 12시가 S극(1) → 4점
  - 4번 톱니 12시가 S극(1) → 8점

## 4. 문제를 상태로 표현하기
- **문제 상태(State)** 는 무엇으로 표현할 수 있는가?
  - 네 개의 톱니바퀴가 맞닿아 있는 상태
  - K 번 회전시킨 후 네 톱니바퀴의 12시 방향을 가리키는 극의 종류
- 상태 변화는 어떤 조건에서 발생하는가?
  - 주어진 번호의 톱니바퀴가 회전할 때

## 5. 목표 조건
- 언제 종료되는가? 어떤 값이 최적해인가?
  - K 번 회전 후 종료

## 6. 풀이 방법
- 어떤 알고리즘/기법을 사용할 수 있을까?
  - 시뮬레이션

## 7. 로직 흐름 요약
1. 입력 받기
2. 초기 톱니바퀴 상태 설정
   - 톱니의 상태를 deque로 관리
      - 시계방향 회전 시 pop() 후 insert()
      - 반시계방향 회전 시 popleft() 후 append()
   - 맞닿아 있는 톱니의 index 설정
      - 맞닿아 있는 톱니에 해당하는 index의 값이 다른 경우 한 톱니바퀴 회전 시 영향 없음
      - 맞닿아 있는 톱니에 해당하는 index의 값이 같은 경우 한 톱니바퀴 회전 시 반대 방향 회전
3. 문제 풀이 로직
   - K 번의 회전 동안 각 톱니바퀴의 움직임 구현
   - 각 톱니바퀴의 12시 방향의 톱니에 해당하는 index 0번의 값을 모두 더해 점수의 합을 계산
4. 정답 출력
